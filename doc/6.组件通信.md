# 6. React 组件通信

## 概述

React 组件使用 **props** 来互相通信。每个父组件都可以通过 props 向子组件传递信息。Props 可以传递任何 JavaScript 值，包括对象、数组、函数以及 JSX 元素，使组件更加灵活。

## Props 基础概念

### 类比 HTML 属性

就像在 HTML 中为标签传递属性一样：

```html
<img width="500" height="500" alt="xxx" src="xxxxxxx" />
```

在 React 中，也可以为自定义组件传递属性：

```tsx
export default function App() {
  return <Card title="标题1" content="内容"></Card>;
}
```

### 单向数据流

React 遵循**单向数据流**原则：
- 数据从父组件流向子组件
- 子组件不能直接修改父组件的 props
- React 会使用 `Object.freeze()` 冻结 props，防止被修改

---

## 父子组件通信

### 项目结构

```
src/
├── components/
│   ├── Father/
│   │   └── index.tsx    # 父组件
│   ├── Son/
│   │   └── index.tsx    # 子组件
│   └── Brother/
│       └── index.tsx    # 兄弟组件
└── App.tsx
```

### 1. 父向子传递 Props

#### 支持的数据类型

Props 支持传递所有 JavaScript 数据类型：

```tsx
// 项目实际代码 - Father/index.tsx：
import Son from "../Son";

function Father() {
  const cb = (params: string) => {
    console.log("子组件触发了 父组件的事件", params);
  };

  return (
    <Son
      id={123}                                    // number
      bool={false}                               // boolean
      obj={{ a: 1, b: "1" }}                   // object
      arr={[1, 2, 3]}                           // array
      fn={(a: number, b: number) => a + b}      // function
      empty={null}                              // null
      element={<div>元素</div>}                  // JSX.Element
      cb={cb}                                   // callback function
    >
      <div>123</div>                            {/* children */}
    </Son>
  );
}
```

### 2. 子组件接收 Props

#### TypeScript 接口定义

```tsx
// 项目实际代码 - Son/index.tsx：
import React, { type JSX } from "react";

interface Props {
  title: string;
  id: number;
  bool: boolean;
  obj: {
    a: number;
    b: string;
  };
  arr: number[];
  fn: (a: number, b: number) => number;
  empty: null;
  element: JSX.Element;
  children: React.ReactNode;  // React 18 需要手动声明
  cb: (params: string) => void;
}
```

#### 接收和使用 Props

```tsx
// 基础用法：
const Son: React.FC<Props> = (props) => {
  console.log(props);
  return <div>son</div>;
};
```

### 3. 默认值设置

#### 方法一：解构赋值设置默认值

```tsx
// 项目实际代码 - 推荐方式：
type defaultProps = Omit<Props, "title"> & {
  title?: string;
};

const Son: React.FC<defaultProps> = ({
  title = "默认标题",
  children,
  cb
}) => {
  return (
    <>
      <div>{title}</div>
      {children}
      <button onClick={() => cb("这是参数")}>子传父</button>
    </>
  );
};
```

#### 方法二：defaultProps（传统方式）

```tsx
const defaultProps: Partial<Props> = {
  title: "默认标题",
};

const Son: React.FC<Props> = (props) => {
  const { title } = { ...defaultProps, ...props };
  return <div>{title}</div>;
};
```

### 4. children 特殊属性

类似于 Vue 的插槽功能，允许父组件向子组件传递 JSX 内容：

```tsx
// 父组件传递：
<Son>
  <div>123</div>  {/* 这部分会成为 children */}
</Son>

// 子组件接收：
const Son: React.FC<Props> = ({ children }) => {
  return <div>{children}</div>;  // 渲染父组件传递的内容
};
```

**注意**：React 18 中需要手动声明 `children: React.ReactNode` 类型。

### 5. 子向父传递数据

React 没有像 Vue 那样的 `emit` 事件系统，通过**回调函数**实现子向父传递数据：

```tsx
// 项目实际代码 - 父组件定义回调：
const Father = () => {
  const cb = (params: string) => {
    console.log("子组件触发了 父组件的事件", params);
  };

  return <Son cb={cb} />;
};

// 子组件调用回调：
const Son: React.FC<Props> = ({ cb }) => {
  return (
    <button onClick={() => cb("这是参数")}>子传父</button>
  );
};
```

**原理**：本质是利用 JavaScript 函数的回调机制，子组件调用父组件传递的函数，并传递参数。

---

## 兄弟组件通信

兄弟组件之间没有直接的父子关系，需要通过**发布订阅模式**进行通信。

### 实现方式

#### 使用浏览器原生事件系统

```tsx
// 项目实际代码 - Son 组件（发布者）：
const event = new Event("msg");

const clickTap = () => {
  event.params = { msg: "来自Son组件消息" };
  window.dispatchEvent(event);  // 发布事件
};

// TypeScript 类型扩充
declare global {
  interface Event {
    params: unknown;
  }
}

const Son = () => {
  return <button onClick={clickTap}>派发事件</button>;
};
```

```tsx
// 项目实际代码 - Brother 组件（订阅者）：
export default function Brother() {
  // 监听事件
  window.addEventListener("msg", (e) => {
    console.log("Brother组件接收到了", e.params);
  });

  return <div className="card"></div>;
}
```

### 发布订阅模式原理

1. **发布者**：创建事件并通过 `dispatchEvent` 发布
2. **订阅者**：通过 `addEventListener` 监听事件
3. **事件中心**：`window` 对象作为全局事件中心
4. **数据传递**：通过扩展 `Event` 对象的 `params` 属性传递数据

### 第三方库选择

如果不想使用浏览器原生 API，可以选择：
- **mitt**：轻量级事件发射器
- **eventemitter3**：高性能事件发射器
- **状态管理库**：Redux、Zustand、Context API 等

---

## React.FC 类型说明

### 基本概念

`React.FC` 是 TypeScript 中函数组件的类型定义：
- **FC** = Function Component
- 帮助自动推导 Props 类型
- 提供更好的 TypeScript 支持

### 版本差异

- **旧版本**：`React.FC` 自动包含 `PropsWithChildren`
- **新版本**：需要手动声明 `children: React.ReactNode`

```tsx
// React 18 推荐写法：
interface Props {
  title: string;
  children?: React.ReactNode;  // 手动声明
}

const Component: React.FC<Props> = ({ title, children }) => {
  return <div>{title}{children}</div>;
};
```

---

## 通信方式总结

| 通信类型 | 实现方式 | 使用场景 | 特点 |
|----------|----------|----------|------|
| **父→子** | Props | 数据展示、配置传递 | 直接、类型安全 |
| **子→父** | 回调函数 | 事件处理、状态更新 | 函数回调 |
| **兄弟组件** | 发布订阅 | 跨组件通信 | 解耦、灵活 |
| **跨层级** | Context API | 全局状态、主题配置 | 避免 props 钻取 |

---

## 最佳实践

### 1. Props 类型定义

```tsx
// 推荐：使用 interface 定义 props 类型
interface ComponentProps {
  title: string;
  onClick?: () => void;        // 可选属性
  children?: React.ReactNode;  // children 类型
}
```

### 2. 默认值处理

```tsx
// 推荐：使用解构赋值设置默认值
const Component: React.FC<Props> = ({
  title = "默认值",
  onClick = () => {}
}) => {
  // 组件逻辑
};
```

### 3. 回调函数命名

```tsx
// 推荐：使用 on 前缀命名事件处理函数
interface Props {
  onSubmit: (data: FormData) => void;
  onChange: (value: string) => void;
  onError?: (error: Error) => void;
}
```

### 4. 性能优化

#### React.memo 简介

React.memo 是一个**高阶组件**，用于优化函数组件的性能：

**作用**：
- 防止组件不必要的重新渲染
- 通过浅比较 props 来决定是否重新渲染
- 类似于类组件中的 `PureComponent`

**工作原理**：
1. memo 会对比组件的 props 是否发生变化
2. 如果 props 没有变化，就跳过重新渲染
3. 如果 props 发生变化，才会重新渲染组件

```tsx
import React, { memo } from 'react';

// 没有优化：父组件重渲染，子组件也会重渲染
const RegularComponent = ({ title, onClick }: Props) => {
  return <button onClick={onClick}>{title}</button>;
};

// 使用 memo 优化：只有 props 变化时才重渲染
const OptimizedComponent = memo(({ title, onClick }: Props) => {
  return <button onClick={onClick}>{title}</button>;
});
```

**使用场景**：
- 组件经常接收相同的 props
- 组件渲染开销较大
- 父组件频繁重新渲染，但子组件的 props 很少变化

**注意**：这是**性能优化**的高级概念，现在先了解即可，详细用法会在后续的性能优化章节中讲解。

---

## 总结

React 组件通信是构建复杂应用的基础：

1. **Props 是核心**：理解 props 的传递机制和类型系统
2. **单向数据流**：遵循 React 的数据流向原则
3. **回调函数**：实现子向父通信的标准方式
4. **发布订阅**：解决兄弟组件和跨层级通信
5. **类型安全**：充分利用 TypeScript 的类型检查

合理选择通信方式能让组件间的数据流更加清晰和可维护。