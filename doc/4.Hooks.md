# 4. React Hooks

## useState Hook

### 概述

useState 是 React 最基础和最重要的 Hook，它允许函数组件拥有内部状态。组件通常需要根据用户交互来更改显示的内容，这些可变的值就是组件的状态（state）。

### 基本语法

```tsx
const [state, setState] = useState(initialState)
```

- **参数**：`initialState` - 状态的初始值
- **返回值**：数组，包含两个元素：
  - `state`：当前的状态值
  - `setState`：更新状态的函数

### 使用规则

- 只能在组件的**顶层**调用，不能在循环、条件语句或嵌套函数中调用
- 在严格模式下，React 会两次调用初始化函数来帮助发现副作用问题

### 基本用法示例

基于项目中的实际代码：

```tsx
import { useState } from "react";

function App() {
  let one = "空"; // 普通变量（不会触发重渲染）
  const [name, setName] = useState("派蒙"); // 状态变量
  const [arr, setArr] = useState([1, 2, 3]);

  const heandleClick = () => {
    one = "荧"; // 普通变量修改不会触发重渲染
    setName("阿斯莫代"); // 状态修改会触发重渲染
  };

  return (
    <>
      <button onClick={heandleClick}>click</button>
      <div>{one}</div>  {/* 不会更新显示 */}
      <div>{name}</div> {/* 会更新显示 */}
    </>
  );
}
```

**重要区别**：普通变量的修改不会触发组件重新渲染，只有状态变量的修改才会。
## 复杂数据类型状态管理

### 数组状态

在 React 中，状态应该被视为**不可变的**，不能直接修改原数组。必须创建新数组来更新状态。

#### 数组操作对比表

| 操作类型 | ❌ 避免使用（会改变原数组） | ✅ 推荐使用（返回新数组） |
|---------|---------------------------|-------------------------|
| 添加元素 | `push`、`unshift` | `concat`、`[...arr]` 展开语法 |
| 删除元素 | `pop`、`shift`、`splice` | `filter`、`slice` |
| 替换元素 | `splice`、`arr[i] = ...` | `map` |
| 排序 | `reverse`、`sort` | 先复制数组再操作 |
#### 数组添加元素

```tsx
// 在项目代码中的示例（注释部分）：
setArr([4, 5, 6]);           // 替换整个数组
setArr([0, ...arr]);         // 在头部添加元素
setArr([...arr, 4]);         // 在尾部添加元素
```
#### 数组删除元素

```tsx
// 在项目代码中的示例（注释部分）：
setArr(arr.filter((item) => item !== 1)); // 删除指定元素
```
#### 数组元素替换

```tsx
// 在项目代码中的示例（注释部分）：
setArr(
  arr.map((item) => {
    return item == 1 ? 111 : item; // 将值为1的元素替换为111
  })
);
```
#### 指定位置插入元素

```tsx
// 在项目代码中的示例（注释部分）：
const startIndex = 0;
const endIndex = 1;
setArr([
  ...arr.slice(startIndex, endIndex), // 前半部分
  0.5,                                  // 插入的元素
  ...arr.slice(endIndex)               // 后半部分
]);
```

使用 `slice()` 方法截取数组的不同部分，然后用展开运算符组合成新数组。
#### 数组排序和反转

```tsx
// 项目代码中的实际示例：
const newList = [...arr].map((v) => v + 1); // 先复制数组并修改每个元素
// newList.sort((a, b) => b - a);           // 排序（注释掉了）
newList.reverse();                          // 反转数组
setArr(newList);
```

**关键点**：必须先创建数组的副本，再进行排序或反转操作，避免直接修改原数组。
### 对象状态

#### 初始化函数

useState 可以接受一个函数作为初始值，这个函数只在组件首次渲染时执行一次：

```tsx
// 项目代码中的实际示例：
const [obj, setObject] = useState(() => {
  const date =
    new Date().getFullYear() +
    "-" +
    (new Date().getMonth() + 1) +
    "-" +
    new Date().getDate();
  return {
    date,
    name: "温迪",
    age: 6000,
  };
});
```

#### 对象状态更新

更新对象状态时必须创建新对象，不能直接修改原对象的属性：

```tsx
// 项目代码中的实际示例：
setObject({
  ...obj,           // 展开原对象的所有属性
  name: "巴巴托斯", // 更新特定属性
});

// 或者使用 Object.assign
// setObject(Object.assign({}, obj, { name: "巴巴托斯" }));
```
## useState 更新机制

### 异步更新

setState 函数是**异步执行**的，调用后不会立即更新状态值：

```tsx
const [index, setIndex] = useState(0);

const handleClick = () => {
  setIndex(index + 1);
  console.log(index); // 仍然是 0，不是 1
};
```

这种设计是为了性能优化，React 会批量处理状态更新。

### 状态更新的批处理

当在同一个事件处理函数中多次调用 setState 时，React 会将这些更新合并：

```tsx
const handleClick = () => {
  setIndex(index + 1); // 假设 index 为 0，这里计算为 1
  setIndex(index + 1); // 这里 index 仍然是 0，计算为 1
  setIndex(index + 1); // 这里 index 仍然是 0，计算为 1
};
// 最终结果：index 变为 1，而不是 3
```

### 函数式更新

要解决上述问题，可以传递一个函数给 setState，函数会接收当前状态作为参数：

```tsx
const handleClick = () => {
  setIndex(prev => prev + 1); // 1
  setIndex(prev => prev + 1); // 2
  setIndex(prev => prev + 1); // 3
};
// 最终结果：index 变为 3
```

函数式更新确保每次都能获取到最新的状态值进行计算。

### 命名规范

按照惯例，函数式更新的参数通常命名为：
- `prev` + 状态名（如 `prevIndex`）
- 状态名的首字母（如 `i` 代表 `index`）
- 或者其他清晰表示"前一个值"的名称

---

## useEffect Hook

### 概述

useEffect 是 React 中用于处理**副作用**的 Hook。它让函数组件能够执行副作用操作，如数据获取、DOM 操作、订阅事件等。

### 纯函数 vs 副作用函数

#### 纯函数
- **输入决定输出**：相同的输入永远得到相同的输出
- **无副作用**：不修改外部状态，不依赖外部可变状态

```tsx
const add = (x: number, y: number) => x + y;
add(1, 2); // 永远返回 3
```

#### 副作用函数
副作用函数会改变外部状态或依赖外部可变状态：

```tsx
let a = 0;
function fn(number: number) {
  a += 1;                                    // 修改外部变量
  localStorage.setItem('a', String(a));      // 操作本地存储
  fetch('/api/data');                        // 网络请求
  document.querySelector('.app')!.style.color = 'red'; // DOM 操作
  return number * 2;
}
```

**常见副作用**：操作 DOM、网络请求、本地存储、定时器、事件监听等。

### 基本语法

```tsx
useEffect(setup, dependencies?)
```

- **setup**：副作用处理函数，可以返回清理函数
- **dependencies**（可选）：依赖项数组，决定何时重新执行副作用
- **返回值**：`undefined`

### 执行时机和依赖项

根据您的项目代码实例：

#### 1. 组件挂载时执行（类似 componentDidMount）

```tsx
// 项目代码示例：
useEffect(() => {
  console.log("组件挂载时执行");
});
```

#### 2. DOM 操作

```tsx
// 项目代码示例：
useEffect(() => {
  const data = document.getElementById("data");
  console.log(data); // 能够获取到 DOM 元素
}, []);
```

#### 3. 网络请求

```tsx
// 项目代码示例：
useEffect(() => {
  fetch("http://localhost:5173/");
}, []);
```

#### 4. 无依赖项更新

```tsx
// 项目代码示例：每次组件重新渲染都会执行
useEffect(() => {
  console.log("无依赖项更新", count, name);
});
```

#### 5. 有依赖项更新

```tsx
// 项目代码示例：只有 count 改变时才执行
useEffect(() => {
  console.log("执行了", count);
}, [count]); // name 改变不会触发此 effect
```

#### 6. 空依赖项数组

```tsx
// 项目代码示例：只在挂载时执行一次
useEffect(() => {
  console.log("依赖项空值");
}, []); // 仅挂载时执行
```

### 清理函数

useEffect 可以返回一个清理函数，用于清除副作用：

```tsx
// 项目代码中的实际示例：
const Child = (props: { name: string }) => {
  useEffect(() => {
    console.log("副作用函数执行", props.name);
    // 返回清理函数
    return () => {
      console.log("先执行清理函数", props.name);
    };
  }, [props.name]);
  return <div>Child:{props.name}</div>;
};
```

**清理函数的执行时机**：
1. 组件卸载时
2. 依赖项变化导致副作用重新执行之前
3. 下一次 effect 执行之前

### 实际应用场景

#### 防抖处理

```tsx
// 项目代码中的防抖示例（注释部分）：
const Child = (props: { name: string }) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      fetch("http://localhost:5173/");
    }, 1000);
    return () => {
      clearTimeout(timer); // 清理定时器，避免重复请求
    };
  }, [props.name]);
  return <div>Child</div>;
};
```

### 与类组件生命周期的对比

| useEffect 用法 | 类组件生命周期 |
|----------------|----------------|
| `useEffect(() => {})` | `componentDidMount` + `componentDidUpdate` |
| `useEffect(() => {}, [])` | `componentDidMount` |
| `useEffect(() => {}, [dep])` | `componentDidMount` + `componentDidUpdate`（仅当 dep 变化） |
| `useEffect(() => { return cleanup }, [])` | `componentDidMount` + `componentWillUnmount` |

### 注意事项

1. **避免无限循环**：确保依赖项数组正确，避免在 effect 内部修改依赖项
2. **清理副作用**：始终清理定时器、事件监听器、订阅等
3. **条件执行**：使用依赖项数组控制 effect 的执行时机
4. **StrictMode**：在严格模式下，effect 会执行两次以帮助发现问题

---

## 更多 Hooks


---

*持续更新中...*