# 4. React Hooks

## useState Hook

### 概述

useState 是 React 最基础和最重要的 Hook，它允许函数组件拥有内部状态。组件通常需要根据用户交互来更改显示的内容，这些可变的值就是组件的状态（state）。

### 基本语法

```tsx
const [state, setState] = useState(initialState)
```

- **参数**：`initialState` - 状态的初始值
- **返回值**：数组，包含两个元素：
  - `state`：当前的状态值
  - `setState`：更新状态的函数

### 使用规则

- 只能在组件的**顶层**调用，不能在循环、条件语句或嵌套函数中调用
- 在严格模式下，React 会两次调用初始化函数来帮助发现副作用问题

### 基本用法示例

基于项目中的实际代码：

```tsx
import { useState } from "react";

function App() {
  let one = "空"; // 普通变量（不会触发重渲染）
  const [name, setName] = useState("派蒙"); // 状态变量
  const [arr, setArr] = useState([1, 2, 3]);

  const heandleClick = () => {
    one = "荧"; // 普通变量修改不会触发重渲染
    setName("阿斯莫代"); // 状态修改会触发重渲染
  };

  return (
    <>
      <button onClick={heandleClick}>click</button>
      <div>{one}</div>  {/* 不会更新显示 */}
      <div>{name}</div> {/* 会更新显示 */}
    </>
  );
}
```

**重要区别**：普通变量的修改不会触发组件重新渲染，只有状态变量的修改才会。
## 复杂数据类型状态管理

### 数组状态

在 React 中，状态应该被视为**不可变的**，不能直接修改原数组。必须创建新数组来更新状态。

#### 数组操作对比表

| 操作类型 | ❌ 避免使用（会改变原数组） | ✅ 推荐使用（返回新数组） |
|---------|---------------------------|-------------------------|
| 添加元素 | `push`、`unshift` | `concat`、`[...arr]` 展开语法 |
| 删除元素 | `pop`、`shift`、`splice` | `filter`、`slice` |
| 替换元素 | `splice`、`arr[i] = ...` | `map` |
| 排序 | `reverse`、`sort` | 先复制数组再操作 |
#### 数组添加元素

```tsx
// 在项目代码中的示例（注释部分）：
setArr([4, 5, 6]);           // 替换整个数组
setArr([0, ...arr]);         // 在头部添加元素
setArr([...arr, 4]);         // 在尾部添加元素
```
#### 数组删除元素

```tsx
// 在项目代码中的示例（注释部分）：
setArr(arr.filter((item) => item !== 1)); // 删除指定元素
```
#### 数组元素替换

```tsx
// 在项目代码中的示例（注释部分）：
setArr(
  arr.map((item) => {
    return item == 1 ? 111 : item; // 将值为1的元素替换为111
  })
);
```
#### 指定位置插入元素

```tsx
// 在项目代码中的示例（注释部分）：
const startIndex = 0;
const endIndex = 1;
setArr([
  ...arr.slice(startIndex, endIndex), // 前半部分
  0.5,                                  // 插入的元素
  ...arr.slice(endIndex)               // 后半部分
]);
```

使用 `slice()` 方法截取数组的不同部分，然后用展开运算符组合成新数组。
#### 数组排序和反转

```tsx
// 项目代码中的实际示例：
const newList = [...arr].map((v) => v + 1); // 先复制数组并修改每个元素
// newList.sort((a, b) => b - a);           // 排序（注释掉了）
newList.reverse();                          // 反转数组
setArr(newList);
```

**关键点**：必须先创建数组的副本，再进行排序或反转操作，避免直接修改原数组。
### 对象状态

#### 初始化函数

useState 可以接受一个函数作为初始值，这个函数只在组件首次渲染时执行一次：

```tsx
// 项目代码中的实际示例：
const [obj, setObject] = useState(() => {
  const date =
    new Date().getFullYear() +
    "-" +
    (new Date().getMonth() + 1) +
    "-" +
    new Date().getDate();
  return {
    date,
    name: "温迪",
    age: 6000,
  };
});
```

#### 对象状态更新

更新对象状态时必须创建新对象，不能直接修改原对象的属性：

```tsx
// 项目代码中的实际示例：
setObject({
  ...obj,           // 展开原对象的所有属性
  name: "巴巴托斯", // 更新特定属性
});

// 或者使用 Object.assign
// setObject(Object.assign({}, obj, { name: "巴巴托斯" }));
```
## useState 更新机制

### 异步更新

setState 函数是**异步执行**的，调用后不会立即更新状态值：

```tsx
const [index, setIndex] = useState(0);

const handleClick = () => {
  setIndex(index + 1);
  console.log(index); // 仍然是 0，不是 1
};
```

这种设计是为了性能优化，React 会批量处理状态更新。

### 状态更新的批处理

当在同一个事件处理函数中多次调用 setState 时，React 会将这些更新合并：

```tsx
const handleClick = () => {
  setIndex(index + 1); // 假设 index 为 0，这里计算为 1
  setIndex(index + 1); // 这里 index 仍然是 0，计算为 1
  setIndex(index + 1); // 这里 index 仍然是 0，计算为 1
};
// 最终结果：index 变为 1，而不是 3
```

### 函数式更新

要解决上述问题，可以传递一个函数给 setState，函数会接收当前状态作为参数：

```tsx
const handleClick = () => {
  setIndex(prev => prev + 1); // 1
  setIndex(prev => prev + 1); // 2
  setIndex(prev => prev + 1); // 3
};
// 最终结果：index 变为 3
```

函数式更新确保每次都能获取到最新的状态值进行计算。

### 命名规范

按照惯例，函数式更新的参数通常命名为：
- `prev` + 状态名（如 `prevIndex`）
- 状态名的首字母（如 `i` 代表 `index`）
- 或者其他清晰表示"前一个值"的名称

---

## useEffect Hook

### 概述

useEffect 是 React 中用于处理**副作用**的 Hook。它让函数组件能够执行副作用操作，如数据获取、DOM 操作、订阅事件等。

### 纯函数 vs 副作用函数

#### 纯函数
- **输入决定输出**：相同的输入永远得到相同的输出
- **无副作用**：不修改外部状态，不依赖外部可变状态

```tsx
const add = (x: number, y: number) => x + y;
add(1, 2); // 永远返回 3
```

#### 副作用函数
副作用函数会改变外部状态或依赖外部可变状态：

```tsx
let a = 0;
function fn(number: number) {
  a += 1;                                    // 修改外部变量
  localStorage.setItem('a', String(a));      // 操作本地存储
  fetch('/api/data');                        // 网络请求
  document.querySelector('.app')!.style.color = 'red'; // DOM 操作
  return number * 2;
}
```

**常见副作用**：操作 DOM、网络请求、本地存储、定时器、事件监听等。

### 基本语法

```tsx
useEffect(setup, dependencies?)
```

- **setup**：副作用处理函数，可以返回清理函数
- **dependencies**（可选）：依赖项数组，决定何时重新执行副作用
- **返回值**：`undefined`

### 执行时机和依赖项

根据您的项目代码实例：

#### 1. 组件挂载时执行（类似 componentDidMount）

```tsx
// 项目代码示例：
useEffect(() => {
  console.log("组件挂载时执行");
});
```

#### 2. DOM 操作

```tsx
// 项目代码示例：
useEffect(() => {
  const data = document.getElementById("data");
  console.log(data); // 能够获取到 DOM 元素
}, []);
```

#### 3. 网络请求

```tsx
// 项目代码示例：
useEffect(() => {
  fetch("http://localhost:5173/");
}, []);
```

#### 4. 无依赖项更新

```tsx
// 项目代码示例：每次组件重新渲染都会执行
useEffect(() => {
  console.log("无依赖项更新", count, name);
});
```

#### 5. 有依赖项更新

```tsx
// 项目代码示例：只有 count 改变时才执行
useEffect(() => {
  console.log("执行了", count);
}, [count]); // name 改变不会触发此 effect
```

#### 6. 空依赖项数组

```tsx
// 项目代码示例：只在挂载时执行一次
useEffect(() => {
  console.log("依赖项空值");
}, []); // 仅挂载时执行
```

### 清理函数

useEffect 可以返回一个清理函数，用于清除副作用：

```tsx
// 项目代码中的实际示例：
const Child = (props: { name: string }) => {
  useEffect(() => {
    console.log("副作用函数执行", props.name);
    // 返回清理函数
    return () => {
      console.log("先执行清理函数", props.name);
    };
  }, [props.name]);
  return <div>Child:{props.name}</div>;
};
```

**清理函数的执行时机**：
1. 组件卸载时
2. 依赖项变化导致副作用重新执行之前
3. 下一次 effect 执行之前

### 实际应用场景

#### 防抖处理

```tsx
// 项目代码中的防抖示例（注释部分）：
const Child = (props: { name: string }) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      fetch("http://localhost:5173/");
    }, 1000);
    return () => {
      clearTimeout(timer); // 清理定时器，避免重复请求
    };
  }, [props.name]);
  return <div>Child</div>;
};
```

### 与类组件生命周期的对比

| useEffect 用法 | 类组件生命周期 |
|----------------|----------------|
| `useEffect(() => {})` | `componentDidMount` + `componentDidUpdate` |
| `useEffect(() => {}, [])` | `componentDidMount` |
| `useEffect(() => {}, [dep])` | `componentDidMount` + `componentDidUpdate`（仅当 dep 变化） |
| `useEffect(() => { return cleanup }, [])` | `componentDidMount` + `componentWillUnmount` |

### 注意事项

1. **避免无限循环**：确保依赖项数组正确，避免在 effect 内部修改依赖项
2. **清理副作用**：始终清理定时器、事件监听器、订阅等
3. **条件执行**：使用依赖项数组控制 effect 的执行时机
4. **StrictMode**：在严格模式下，effect 会执行两次以帮助发现问题

---

## useRef Hook

### 概述

useRef 是 React 中用于在组件渲染之间保持持久性数据的 Hook。它有两个主要用途:

1. **操作 DOM 元素**:获取和操作真实的 DOM 节点
2. **存储可变数据**:保存在渲染之间需要持久化但不触发重新渲染的数据

### 基本语法

```tsx
import { useRef } from 'react';
const refValue = useRef(initialValue);
refValue.current // 访问 ref 的值
```

**参数**:
- `initialValue`:ref 对象的 `current` 属性的初始值,可以是任意类型。这个参数在首次渲染后被忽略。

**返回值**:
- 返回一个对象:`{ current: initialValue }`

### 与 Vue Ref 的对比

| 特性 | React useRef | Vue ref |
|------|-------------|---------|
| 访问方式 | `.current` | `.value` |
| 响应式 | ❌ 非响应式 | ✅ 响应式 |
| 修改触发渲染 | ❌ 不触发 | ✅ 触发 |

### 使用场景 1:操作 DOM 元素

```tsx
// 项目代码示例:
import { useRef } from "react";

const App = () => {
  // 1. 声明一个初始值为 null 的 ref 对象
  const div = useRef(null);

  const handleClick = () => {
    // 3. 当 React 创建 DOM 节点并渲染到屏幕时,
    // React 会把 DOM 节点设置为 ref 对象的 current 属性
    console.log(div.current);
  };

  return (
    <>
      {/* 2. 将 ref 对象作为 ref 属性传递给想要操作的 DOM 节点 */}
      <div ref={div}>dom元素</div>
      <button onClick={handleClick}>获取dom元素</button>
    </>
  );
};
```

### 使用场景 2:存储可变数据

#### 问题:普通变量会被重置

```tsx
// ❌ 错误示例:
const App = () => {
  let num = 0; // 每次渲染都会重置为 0
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);  // 触发重新渲染
    num = count;           // num 会在下次渲染时重置为 0
  };

  return (
    <div>
      <button onClick={handleClick}>增加</button>
      <div>{count}:{num}</div> {/* num 永远显示 0 */}
    </div>
  );
};
```

**原因**:当 `setCount` 执行后,组件会重新渲染,`num` 会被重新初始化为 0。

#### 解决方案:使用 useRef

```tsx
// ✅ 正确示例(项目代码):
const App = () => {
  const num = useRef(0); // useRef 的值在渲染之间保持不变
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    num.current = count;  // 保存当前值,不会被重置
  };

  return (
    <div>
      <button onClick={handleClick}>增加</button>
      <div>count:{count} | num:{num.current}</div>
    </div>
  );
};
```

**关键点**:useRef 只会在初始化时执行一次,组件重新渲染时,useRef 的值不会被重新初始化。

### 使用场景 3:定时器引用

#### 问题:定时器无法清除

```tsx
// ❌ 错误示例:
const App = () => {
  let timer: ReturnType<typeof setInterval> | null = null;
  const [count, setCount] = useState(0);

  const handleStart = () => {
    timer = setInterval(() => {
      setCount(count => count + 1);
    }, 300);
  };

  const handleEnd = () => {
    console.log(timer); // timer 为 null!
    if (timer) {
      clearInterval(timer); // 永远不会执行
    }
  };

  return (
    <div>
      <button onClick={handleStart}>开始计数</button>
      <button onClick={handleEnd}>结束计数</button>
      <div>{count}</div>
    </div>
  );
};
```

**原因**:每次组件重新渲染时,`timer` 都会被重置为 `null`,导致 `clearInterval` 无法清除定时器,造成内存泄漏。

#### 解决方案:使用 useRef 存储定时器 ID

```tsx
// ✅ 正确示例(项目代码):
const App = () => {
  const timer = useRef<ReturnType<typeof setInterval> | null>(null);
  const [t, setT] = useState(0);

  const handleStart = () => {
    timer.current = setInterval(() => {
      setT((t) => t + 1);
    }, 300);
  };

  const handleEnd = () => {
    console.log(timer.current); // 能正确获取定时器 ID
    if (timer.current) {
      clearInterval(timer.current);
      timer.current = null;
    }
  };

  return (
    <div>
      <button onClick={handleStart}>开始计数</button>
      <button onClick={handleEnd}>结束计数</button>
      <div>{t}</div>
    </div>
  );
};
```

#### 改进:防止重复启动定时器

```tsx
const handleStart = () => {
  // 如果已有定时器在运行,先清除
  if (timer.current) {
    clearInterval(timer.current);
  }
  timer.current = setInterval(() => {
    setT((t) => t + 1);
  }, 300);
};
```

这样可以避免连续点击"开始计数"按钮导致多个定时器同时运行的问题。

### useRef 的特性

1. **不触发重新渲染**
   - 改变 `ref.current` 属性时,React 不会重新渲染组件
   - React 不知道 ref 何时发生改变,因为 ref 是一个普通的 JavaScript 对象

2. **数据持久化**
   - 组件重新渲染时,useRef 的值不会被重新初始化
   - ref 的值在组件的整个生命周期中保持不变

3. **与 useState 的对比**

| 特性 | useRef | useState |
|------|--------|----------|
| 修改触发渲染 | ❌ 不触发 | ✅ 触发 |
| 值的持久化 | ✅ 持久化 | ✅ 持久化 |
| 适用场景 | DOM 引用、定时器 ID、缓存值 | UI 状态、表单数据 |
| 获取最新值 | 同步获取 | 异步获取(闭包陷阱) |

### 注意事项

1. **不要在渲染期间读写 ref.current**
   - 除了初始化外,不要在渲染期间写入或读取 `ref.current`
   - 否则会使组件行为变得不可预测

2. **不能作为依赖项**
   - useRef 的值不能作为 useEffect 等 Hooks 的依赖项
   - 因为它不是响应式状态,修改不会触发 effect 重新执行

3. **子组件引用需要配合 forwardRef**
   - useRef 不能直接获取子组件的实例
   - 需要使用 `React.forwardRef` 转发 ref

4. **TypeScript 类型注解**
   ```tsx
   // DOM 引用
   const div = useRef<HTMLDivElement>(null);

   // 定时器引用
   const timer = useRef<ReturnType<typeof setInterval> | null>(null);

   // 普通数据
   const count = useRef<number>(0);
   ```

### 最佳实践

1. **清理副作用**:定时器、事件监听器等使用 useRef 存储时,务必在组件卸载时清理
2. **避免过度使用**:如果数据变化需要触发 UI 更新,应使用 useState 而非 useRef
3. **命名清晰**:使用有意义的变量名,如 `timerRef`、`inputRef` 等










## 更多 Hooks


---

*持续更新中...*