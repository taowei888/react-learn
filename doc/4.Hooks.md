# 4. React Hooks

## useState Hook

### 概述

useState 是 React 最基础和最重要的 Hook，它允许函数组件拥有内部状态。组件通常需要根据用户交互来更改显示的内容，这些可变的值就是组件的状态（state）。

### 基本语法

```tsx
const [state, setState] = useState(initialState)
```

- **参数**：`initialState` - 状态的初始值
- **返回值**：数组，包含两个元素：
  - `state`：当前的状态值
  - `setState`：更新状态的函数

### 使用规则

- 只能在组件的**顶层**调用，不能在循环、条件语句或嵌套函数中调用
- 在严格模式下，React 会两次调用初始化函数来帮助发现副作用问题

### 基本用法示例

基于项目中的实际代码：

```tsx
import { useState } from "react";

function App() {
  let one = "空"; // 普通变量（不会触发重渲染）
  const [name, setName] = useState("派蒙"); // 状态变量
  const [arr, setArr] = useState([1, 2, 3]);

  const heandleClick = () => {
    one = "荧"; // 普通变量修改不会触发重渲染
    setName("阿斯莫代"); // 状态修改会触发重渲染
  };

  return (
    <>
      <button onClick={heandleClick}>click</button>
      <div>{one}</div>  {/* 不会更新显示 */}
      <div>{name}</div> {/* 会更新显示 */}
    </>
  );
}
```

**重要区别**：普通变量的修改不会触发组件重新渲染，只有状态变量的修改才会。
## 复杂数据类型状态管理

### 数组状态

在 React 中，状态应该被视为**不可变的**，不能直接修改原数组。必须创建新数组来更新状态。

#### 数组操作对比表

| 操作类型 | ❌ 避免使用（会改变原数组） | ✅ 推荐使用（返回新数组） |
|---------|---------------------------|-------------------------|
| 添加元素 | `push`、`unshift` | `concat`、`[...arr]` 展开语法 |
| 删除元素 | `pop`、`shift`、`splice` | `filter`、`slice` |
| 替换元素 | `splice`、`arr[i] = ...` | `map` |
| 排序 | `reverse`、`sort` | 先复制数组再操作 |
#### 数组添加元素

```tsx
// 在项目代码中的示例（注释部分）：
setArr([4, 5, 6]);           // 替换整个数组
setArr([0, ...arr]);         // 在头部添加元素
setArr([...arr, 4]);         // 在尾部添加元素
```
#### 数组删除元素

```tsx
// 在项目代码中的示例（注释部分）：
setArr(arr.filter((item) => item !== 1)); // 删除指定元素
```
#### 数组元素替换

```tsx
// 在项目代码中的示例（注释部分）：
setArr(
  arr.map((item) => {
    return item == 1 ? 111 : item; // 将值为1的元素替换为111
  })
);
```
#### 指定位置插入元素

```tsx
// 在项目代码中的示例（注释部分）：
const startIndex = 0;
const endIndex = 1;
setArr([
  ...arr.slice(startIndex, endIndex), // 前半部分
  0.5,                                  // 插入的元素
  ...arr.slice(endIndex)               // 后半部分
]);
```

使用 `slice()` 方法截取数组的不同部分，然后用展开运算符组合成新数组。
#### 数组排序和反转

```tsx
// 项目代码中的实际示例：
const newList = [...arr].map((v) => v + 1); // 先复制数组并修改每个元素
// newList.sort((a, b) => b - a);           // 排序（注释掉了）
newList.reverse();                          // 反转数组
setArr(newList);
```

**关键点**：必须先创建数组的副本，再进行排序或反转操作，避免直接修改原数组。
### 对象状态

#### 初始化函数

useState 可以接受一个函数作为初始值，这个函数只在组件首次渲染时执行一次：

```tsx
// 项目代码中的实际示例：
const [obj, setObject] = useState(() => {
  const date =
    new Date().getFullYear() +
    "-" +
    (new Date().getMonth() + 1) +
    "-" +
    new Date().getDate();
  return {
    date,
    name: "温迪",
    age: 6000,
  };
});
```

#### 对象状态更新

更新对象状态时必须创建新对象，不能直接修改原对象的属性：

```tsx
// 项目代码中的实际示例：
setObject({
  ...obj,           // 展开原对象的所有属性
  name: "巴巴托斯", // 更新特定属性
});

// 或者使用 Object.assign
// setObject(Object.assign({}, obj, { name: "巴巴托斯" }));
```
## useState 更新机制

### 异步更新

setState 函数是**异步执行**的，调用后不会立即更新状态值：

```tsx
const [index, setIndex] = useState(0);

const handleClick = () => {
  setIndex(index + 1);
  console.log(index); // 仍然是 0，不是 1
};
```

这种设计是为了性能优化，React 会批量处理状态更新。

### 状态更新的批处理

当在同一个事件处理函数中多次调用 setState 时，React 会将这些更新合并：

```tsx
const handleClick = () => {
  setIndex(index + 1); // 假设 index 为 0，这里计算为 1
  setIndex(index + 1); // 这里 index 仍然是 0，计算为 1
  setIndex(index + 1); // 这里 index 仍然是 0，计算为 1
};
// 最终结果：index 变为 1，而不是 3
```

### 函数式更新

要解决上述问题，可以传递一个函数给 setState，函数会接收当前状态作为参数：

```tsx
const handleClick = () => {
  setIndex(prev => prev + 1); // 1
  setIndex(prev => prev + 1); // 2
  setIndex(prev => prev + 1); // 3
};
// 最终结果：index 变为 3
```

函数式更新确保每次都能获取到最新的状态值进行计算。

### 命名规范

按照惯例，函数式更新的参数通常命名为：
- `prev` + 状态名（如 `prevIndex`）
- 状态名的首字母（如 `i` 代表 `index`）
- 或者其他清晰表示"前一个值"的名称

---

## useEffect Hook

### 概述

useEffect 是 React 中用于处理**副作用**的 Hook。它让函数组件能够执行副作用操作，如数据获取、DOM 操作、订阅事件等。

### 纯函数 vs 副作用函数

#### 纯函数
- **输入决定输出**：相同的输入永远得到相同的输出
- **无副作用**：不修改外部状态，不依赖外部可变状态

```tsx
const add = (x: number, y: number) => x + y;
add(1, 2); // 永远返回 3
```

#### 副作用函数
副作用函数会改变外部状态或依赖外部可变状态：

```tsx
let a = 0;
function fn(number: number) {
  a += 1;                                    // 修改外部变量
  localStorage.setItem('a', String(a));      // 操作本地存储
  fetch('/api/data');                        // 网络请求
  document.querySelector('.app')!.style.color = 'red'; // DOM 操作
  return number * 2;
}
```

**常见副作用**：操作 DOM、网络请求、本地存储、定时器、事件监听等。

### 基本语法

```tsx
useEffect(setup, dependencies?)
```

- **setup**：副作用处理函数，可以返回清理函数
- **dependencies**（可选）：依赖项数组，决定何时重新执行副作用
- **返回值**：`undefined`

### 执行时机和依赖项

根据您的项目代码实例：

#### 1. 组件挂载时执行（类似 componentDidMount）

```tsx
// 项目代码示例：
useEffect(() => {
  console.log("组件挂载时执行");
});
```

#### 2. DOM 操作

```tsx
// 项目代码示例：
useEffect(() => {
  const data = document.getElementById("data");
  console.log(data); // 能够获取到 DOM 元素
}, []);
```

#### 3. 网络请求

```tsx
// 项目代码示例：
useEffect(() => {
  fetch("http://localhost:5173/");
}, []);
```

#### 4. 无依赖项更新

```tsx
// 项目代码示例：每次组件重新渲染都会执行
useEffect(() => {
  console.log("无依赖项更新", count, name);
});
```

#### 5. 有依赖项更新

```tsx
// 项目代码示例：只有 count 改变时才执行
useEffect(() => {
  console.log("执行了", count);
}, [count]); // name 改变不会触发此 effect
```

#### 6. 空依赖项数组

```tsx
// 项目代码示例：只在挂载时执行一次
useEffect(() => {
  console.log("依赖项空值");
}, []); // 仅挂载时执行
```

### 清理函数

useEffect 可以返回一个清理函数，用于清除副作用：

```tsx
// 项目代码中的实际示例：
const Child = (props: { name: string }) => {
  useEffect(() => {
    console.log("副作用函数执行", props.name);
    // 返回清理函数
    return () => {
      console.log("先执行清理函数", props.name);
    };
  }, [props.name]);
  return <div>Child:{props.name}</div>;
};
```

**清理函数的执行时机**：
1. 组件卸载时
2. 依赖项变化导致副作用重新执行之前
3. 下一次 effect 执行之前

### 实际应用场景

#### 防抖处理

```tsx
// 项目代码中的防抖示例（注释部分）：
const Child = (props: { name: string }) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      fetch("http://localhost:5173/");
    }, 1000);
    return () => {
      clearTimeout(timer); // 清理定时器，避免重复请求
    };
  }, [props.name]);
  return <div>Child</div>;
};
```

### 与类组件生命周期的对比

| useEffect 用法 | 类组件生命周期 |
|----------------|----------------|
| `useEffect(() => {})` | `componentDidMount` + `componentDidUpdate` |
| `useEffect(() => {}, [])` | `componentDidMount` |
| `useEffect(() => {}, [dep])` | `componentDidMount` + `componentDidUpdate`（仅当 dep 变化） |
| `useEffect(() => { return cleanup }, [])` | `componentDidMount` + `componentWillUnmount` |

### 注意事项

1. **避免无限循环**：确保依赖项数组正确，避免在 effect 内部修改依赖项
2. **清理副作用**：始终清理定时器、事件监听器、订阅等
3. **条件执行**：使用依赖项数组控制 effect 的执行时机
4. **StrictMode**：在严格模式下，effect 会执行两次以帮助发现问题

---

## useRef Hook

### 概述

useRef 是 React 中用于在组件渲染之间保持持久性数据的 Hook。它有两个主要用途:

1. **操作 DOM 元素**:获取和操作真实的 DOM 节点
2. **存储可变数据**:保存在渲染之间需要持久化但不触发重新渲染的数据

### 基本语法

```tsx
import { useRef } from 'react';
const refValue = useRef(initialValue);
refValue.current // 访问 ref 的值
```

**参数**:
- `initialValue`:ref 对象的 `current` 属性的初始值,可以是任意类型。这个参数在首次渲染后被忽略。

**返回值**:
- 返回一个对象:`{ current: initialValue }`

### 与 Vue Ref 的对比

| 特性 | React useRef | Vue ref |
|------|-------------|---------|
| 访问方式 | `.current` | `.value` |
| 响应式 | ❌ 非响应式 | ✅ 响应式 |
| 修改触发渲染 | ❌ 不触发 | ✅ 触发 |

### 使用场景 1:操作 DOM 元素

```tsx
// 项目代码示例:
import { useRef } from "react";

const App = () => {
  // 1. 声明一个初始值为 null 的 ref 对象
  const div = useRef(null);

  const handleClick = () => {
    // 3. 当 React 创建 DOM 节点并渲染到屏幕时,
    // React 会把 DOM 节点设置为 ref 对象的 current 属性
    console.log(div.current);
  };

  return (
    <>
      {/* 2. 将 ref 对象作为 ref 属性传递给想要操作的 DOM 节点 */}
      <div ref={div}>dom元素</div>
      <button onClick={handleClick}>获取dom元素</button>
    </>
  );
};
```

### 使用场景 2:存储可变数据

#### 问题:普通变量会被重置

```tsx
// ❌ 错误示例:
const App = () => {
  let num = 0; // 每次渲染都会重置为 0
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);  // 触发重新渲染
    num = count;           // num 会在下次渲染时重置为 0
  };

  return (
    <div>
      <button onClick={handleClick}>增加</button>
      <div>{count}:{num}</div> {/* num 永远显示 0 */}
    </div>
  );
};
```

**原因**:当 `setCount` 执行后,组件会重新渲染,`num` 会被重新初始化为 0。

#### 解决方案:使用 useRef

```tsx
// ✅ 正确示例(项目代码):
const App = () => {
  const num = useRef(0); // useRef 的值在渲染之间保持不变
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    num.current = count;  // 保存当前值,不会被重置
  };

  return (
    <div>
      <button onClick={handleClick}>增加</button>
      <div>count:{count} | num:{num.current}</div>
    </div>
  );
};
```

**关键点**:useRef 只会在初始化时执行一次,组件重新渲染时,useRef 的值不会被重新初始化。

### 使用场景 3:定时器引用

#### 问题:定时器无法清除

```tsx
// ❌ 错误示例:
const App = () => {
  let timer: ReturnType<typeof setInterval> | null = null;
  const [count, setCount] = useState(0);

  const handleStart = () => {
    timer = setInterval(() => {
      setCount(count => count + 1);
    }, 300);
  };

  const handleEnd = () => {
    console.log(timer); // timer 为 null!
    if (timer) {
      clearInterval(timer); // 永远不会执行
    }
  };

  return (
    <div>
      <button onClick={handleStart}>开始计数</button>
      <button onClick={handleEnd}>结束计数</button>
      <div>{count}</div>
    </div>
  );
};
```

**原因**:每次组件重新渲染时,`timer` 都会被重置为 `null`,导致 `clearInterval` 无法清除定时器,造成内存泄漏。

#### 解决方案:使用 useRef 存储定时器 ID

```tsx
// ✅ 正确示例(项目代码):
const App = () => {
  const timer = useRef<ReturnType<typeof setInterval> | null>(null);
  const [t, setT] = useState(0);

  const handleStart = () => {
    timer.current = setInterval(() => {
      setT((t) => t + 1);
    }, 300);
  };

  const handleEnd = () => {
    console.log(timer.current); // 能正确获取定时器 ID
    if (timer.current) {
      clearInterval(timer.current);
      timer.current = null;
    }
  };

  return (
    <div>
      <button onClick={handleStart}>开始计数</button>
      <button onClick={handleEnd}>结束计数</button>
      <div>{t}</div>
    </div>
  );
};
```

#### 改进:防止重复启动定时器

```tsx
const handleStart = () => {
  // 如果已有定时器在运行,先清除
  if (timer.current) {
    clearInterval(timer.current);
  }
  timer.current = setInterval(() => {
    setT((t) => t + 1);
  }, 300);
};
```

这样可以避免连续点击"开始计数"按钮导致多个定时器同时运行的问题。

### useRef 的特性

1. **不触发重新渲染**
   - 改变 `ref.current` 属性时,React 不会重新渲染组件
   - React 不知道 ref 何时发生改变,因为 ref 是一个普通的 JavaScript 对象

2. **数据持久化**
   - 组件重新渲染时,useRef 的值不会被重新初始化
   - ref 的值在组件的整个生命周期中保持不变

3. **与 useState 的对比**

| 特性 | useRef | useState |
|------|--------|----------|
| 修改触发渲染 | ❌ 不触发 | ✅ 触发 |
| 值的持久化 | ✅ 持久化 | ✅ 持久化 |
| 适用场景 | DOM 引用、定时器 ID、缓存值 | UI 状态、表单数据 |
| 获取最新值 | 同步获取 | 异步获取(闭包陷阱) |

### 注意事项

1. **不要在渲染期间读写 ref.current**
   - 除了初始化外,不要在渲染期间写入或读取 `ref.current`
   - 否则会使组件行为变得不可预测

2. **不能作为依赖项**
   - useRef 的值不能作为 useEffect 等 Hooks 的依赖项
   - 因为它不是响应式状态,修改不会触发 effect 重新执行

3. **子组件引用需要配合 forwardRef**
   - useRef 不能直接获取子组件的实例
   - 需要使用 `React.forwardRef` 转发 ref

4. **TypeScript 类型注解**
   ```tsx
   // DOM 引用
   const div = useRef<HTMLDivElement>(null);

   // 定时器引用
   const timer = useRef<ReturnType<typeof setInterval> | null>(null);

   // 普通数据
   const count = useRef<number>(0);
   ```

### 最佳实践

1. **清理副作用**:定时器、事件监听器等使用 useRef 存储时,务必在组件卸载时清理
2. **避免过度使用**:如果数据变化需要触发 UI 更新,应使用 useState 而非 useRef
3. **命名清晰**:使用有意义的变量名,如 `timerRef`、`inputRef` 等


---

## React.memo 与 useMemo

### 概述

React 提供了两个性能优化工具:

- **React.memo**:用于优化组件渲染,避免不必要的重新渲染
- **useMemo**:用于缓存计算结果,避免重复计算

两者都基于"记忆化(Memoization)"的思想,类似于 Vue 的 `computed` 计算属性。

---

## React.memo

### 定义

React.memo 是一个高阶组件(HOC),用于优化组件性能。它会记忆上一次的渲染结果,仅当 props 发生变化时才会重新渲染组件。

### 基本用法

```tsx
import React from 'react';

const MyComponent = React.memo(({ prop1, prop2 }) => {
  // 组件逻辑
  return <div>{prop1} - {prop2}</div>;
});

const App = () => {
  return <MyComponent prop1="value1" prop2="value2" />;
};
```

**关键点**:React.memo 通常用于**子组件**,防止父组件状态变化导致子组件不必要的重新渲染。

### React 组件的渲染条件

在了解 React.memo 之前,需要先理解组件何时会重新渲染:

1. **组件的 props 发生变化**
2. **组件的 state 发生变化**
3. **useContext 的值发生变化**
4. **父组件重新渲染**(即使 props 没变)

### 案例:不使用 React.memo 的问题

**问题描述**:子组件只用到了 `user` 信息,但父组件每次 `search` 发生变化,子组件也会重新渲染,造成不必要的性能损耗。

```tsx
// ❌ 问题示例:未使用 React.memo
import React, { useState } from 'react';

interface User {
  name: string;
  age: number;
  email: string;
}

interface CardProps {
  user: User;
}

// 普通组件,每次父组件渲染都会重新渲染
const Card = function ({ user }: CardProps) {
  console.log('Card render'); // 每次父组件 state 变化都会打印
  const styles = {
    backgroundColor: 'lightblue',
    padding: '20px',
    borderRadius: '10px',
    margin: '10px'
  };
  return (
    <div style={styles}>
      <h1>{user.name}</h1>
      <p>{user.age}</p>
      <p>{user.email}</p>
    </div>
  );
};

function App() {
  const [users, setUsers] = useState<User>({
    name: '张三',
    age: 18,
    email: 'zhangsan@example.com'
  });
  const [search, setSearch] = useState('');

  return (
    <div>
      <h1>父组件</h1>
      <input value={search} onChange={(e) => setSearch(e.target.value)} />
      <Card user={users} />
    </div>
  );
}

export default App;
```

**问题**:当在输入框中输入内容时,`search` 状态变化导致父组件重新渲染,即使 `user` 没有变化,`Card` 组件也会重新渲染。

### 案例:使用 React.memo 优化

```tsx
// ✅ 优化示例:使用 React.memo
import React, { useState } from 'react';

interface User {
  name: string;
  age: number;
  email: string;
}

interface CardProps {
  user: User;
}

// 使用 React.memo 包裹组件
const Card = React.memo(function ({ user }: CardProps) {
  console.log('Card render'); // 只有 user 变化时才会打印
  const styles = {
    backgroundColor: 'lightblue',
    padding: '20px',
    borderRadius: '10px',
    margin: '10px'
  };
  return (
    <div style={styles}>
      <h1>{user.name}</h1>
      <p>{user.age}</p>
      <p>{user.email}</p>
    </div>
  );
});

function App() {
  const [users, setUsers] = useState<User>({
    name: '张三',
    age: 18,
    email: 'zhangsan@example.com'
  });
  const [search, setSearch] = useState('');

  return (
    <div>
      <h1>父组件</h1>
      <input value={search} onChange={(e) => setSearch(e.target.value)} />
      <div>
        <button onClick={() => setUsers({
          name: '李四',
          age: Math.random() * 100,
          email: 'lisi@example.com'
        })}>更新user</button>
      </div>
      <Card user={users} />
    </div>
  );
}

export default App;
```

**效果**:
- 修改 `search` 时,`Card` 组件**不会**重新渲染
- 点击"更新user"按钮时,`Card` 组件**才会**重新渲染

### React.memo 总结

**使用场景:**
- 子组件接收的 props 不经常变化
- 组件重新渲染的开销较大
- 需要避免不必要的渲染

**优点:**
- 通过记忆化避免不必要的重新渲染
- 提高应用性能
- 减少资源消耗

**注意事项:**
- **不要过度使用**:只在确实需要优化的组件上使用
- **简单组件慎用**:对于简单组件,使用 memo 的开销可能比重新渲染还大
- **props 频繁变化时效果差**:如果 props 经常变化,memo 的效果会大打折扣

---

## useMemo Hook

### 定义

useMemo 是 React 提供的性能优化 Hook,用于缓存计算结果。它通过记忆上一次的计算结果,仅当依赖项变化时才会重新计算,类似于 Vue 的 `computed` 计算属性。

### 基本语法

```tsx
import { useMemo } from 'react';

const memoizedValue = useMemo(() => {
  // 计算逻辑
  return computedValue;
}, [dependency1, dependency2]);
```

**参数:**
- **回调函数** (Function):返回需要缓存的值
- **依赖项数组** (Array):依赖项发生变化时,回调函数会重新执行(执行时机类似 useEffect)

**返回值:**
- 返回缓存的计算结果(不是函数)

### 案例:不使用 useMemo 的问题

**问题描述**:`total` 计算与 `search` 无关,但每次 `search` 变化都会重新计算 `total`,如果计算逻辑复杂,会造成性能问题。

```tsx
// ❌ 问题示例:未使用 useMemo
import { useState } from 'react';

function App() {
  const [search, setSearch] = useState('');
  const [goods, setGoods] = useState([
    { id: 1, name: '苹果', price: 10, count: 1 },
    { id: 2, name: '香蕉', price: 20, count: 1 },
    { id: 3, name: '橘子', price: 30, count: 1 },
  ]);

  const handleAdd = (id: number) => {
    setGoods(goods.map(item =>
      item.id === id ? { ...item, count: item.count + 1 } : item
    ));
  };

  const handleSub = (id: number) => {
    setGoods(goods.map(item =>
      item.id === id ? { ...item, count: item.count - 1 } : item
    ));
  };

  // 每次组件渲染都会重新计算
  const total = () => {
    console.log('计算 total'); // search 变化时也会打印
    return goods.reduce((total, item) => total + item.price * item.count, 0);
  };

  return (
    <div>
      <h1>购物车</h1>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="搜索商品"
      />
      <table border={1} cellPadding={5} cellSpacing={0}>
        <thead>
          <tr>
            <th>商品名称</th>
            <th>商品价格</th>
            <th>商品数量</th>
          </tr>
        </thead>
        <tbody>
          {goods.map(item => (
            <tr key={item.id}>
              <td>{item.name}</td>
              <td>{item.price * item.count}</td>
              <td>
                <button onClick={() => handleAdd(item.id)}>+</button>
                <span>{item.count}</span>
                <button onClick={() => handleSub(item.id)}>-</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      <h2>总价：{total()}</h2>
    </div>
  );
}

export default App;
```

**问题**:在输入框输入内容时,虽然 `goods` 没有变化,但 `total()` 仍然会重新计算。

### 案例:使用 useMemo 优化

```tsx
// ✅ 优化示例:使用 useMemo
import { useMemo, useState } from 'react';

function App() {
  const [search, setSearch] = useState('');
  const [goods, setGoods] = useState([
    { id: 1, name: '苹果', price: 10, count: 1 },
    { id: 2, name: '香蕉', price: 20, count: 1 },
    { id: 3, name: '橘子', price: 30, count: 1 },
  ]);

  const handleAdd = (id: number) => {
    setGoods(goods.map(item =>
      item.id === id ? { ...item, count: item.count + 1 } : item
    ));
  };

  const handleSub = (id: number) => {
    setGoods(goods.map(item =>
      item.id === id ? { ...item, count: item.count - 1 } : item
    ));
  };

  // 使用 useMemo 缓存计算结果
  const total = useMemo(() => {
    console.log('计算 total'); // 只有 goods 变化时才会打印
    return goods.reduce((total, item) => total + item.price * item.count, 0);
  }, [goods]); // 只依赖 goods

  return (
    <div>
      <h1>购物车</h1>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="搜索商品"
      />
      <table border={1} cellPadding={5} cellSpacing={0}>
        <thead>
          <tr>
            <th>商品名称</th>
            <th>商品价格</th>
            <th>商品数量</th>
          </tr>
        </thead>
        <tbody>
          {goods.map(item => (
            <tr key={item.id}>
              <td>{item.name}</td>
              <td>{item.price * item.count}</td>
              <td>
                <button onClick={() => handleAdd(item.id)}>+</button>
                <span>{item.count}</span>
                <button onClick={() => handleSub(item.id)}>-</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      <h2>总价：{total}</h2> {/* 直接使用缓存值,不需要调用函数 */}
    </div>
  );
}

export default App;
```

**效果**:
- 修改 `search` 时,`total` **不会**重新计算
- 点击 +/- 按钮改变 `goods` 时,`total` **才会**重新计算

### 依赖项规则

| 依赖项 | 执行时机 | 推荐度 |
|-------|---------|--------|
| `[]` 空数组 | 只在组件挂载时执行一次 | ✅ 推荐(常量计算) |
| `[dep1, dep2]` 指定依赖项 | 依赖项变化时执行 | ✅ 推荐(最常用) |
| 不传依赖项 | 每次渲染都执行 | ❌ 不推荐(失去缓存意义) |

### useMemo 总结

**使用场景:**
- 需要缓存复杂计算结果
- 避免不必要的重新计算
- 计算逻辑复杂且耗时

**优点:**
- 通过记忆化避免不必要的重新计算
- 提高应用性能
- 减少资源消耗

**注意事项:**
- **不要过度使用**:只在确实需要优化时使用
- **依赖项频繁变化时效果差**:如果依赖项经常变化,useMemo 的效果会大打折扣
- **简单计算慎用**:如果计算逻辑简单,使用 useMemo 的开销可能比重新计算还大

### React.memo vs useMemo 对比

| 特性 | React.memo | useMemo |
|------|------------|---------|
| 作用对象 | 组件 | 值/计算结果 |
| 优化目标 | 避免组件重新渲染 | 避免重复计算 |
| 使用位置 | 组件定义外层 | 组件内部 |
| 比较依据 | props 变化 | 依赖项变化 |
| 返回值 | 记忆化的组件 | 记忆化的值 |
| 类似概念 | Vue 的组件缓存 | Vue 的 computed |

**何时使用:**
- **React.memo**:子组件渲染开销大,props 不常变化
- **useMemo**:计算逻辑复杂,依赖项不常变化

**最佳实践:**
- 先写正常代码,发现性能问题再优化
- 使用 React DevTools Profiler 确认优化效果
- 不要为了优化而优化,保持代码简洁优先










## 更多 Hooks


---

*持续更新中...*