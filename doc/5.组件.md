# 5. React 组件

## 什么是组件？

React 允许你将标签、CSS 和 JavaScript 组合成自定义"组件"，即**应用程序中可复用的 UI 元素**。

## 组件定义

React 组件是一段可以使用标签进行扩展的 JavaScript 函数。组件让你可以将 UI 拆分为独立、可复用的部分。

## 组件类型

### 局部组件

局部组件是在特定页面或模块中使用的组件，需要时才引入。

### 全局组件

全局组件是在应用程序级别使用的组件，通常提供全局功能（如通知、弹窗等）。

---

## 局部组件实践 - Card 组件

### 项目目录结构

```
src/
├── components/
│   └── Card/
│       ├── index.tsx    # 组件主文件
│       └── index.css    # 组件样式
└── App.tsx
```

### 样式文件 (Card/index.css)

```css
.card {
  background: white;
  border-radius: 5px;
  border: 1px solid #ccc;
  max-width: 500px;
  box-shadow: 3px 3px 3px #ccc;
}

.card header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #ccc;
  padding: 10px;
}

.card header div:last-child {
  color: #1677ff;
}

.card main {
  min-height: 200px;
  border-bottom: 1px solid #ccc;
  padding: 10px;
}

.card footer {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  padding: 10px;
}

.card footer button {
  margin-left: 10px;
  padding: 3px 10px;
}
```

### 组件主文件 (Card/index.tsx)

```tsx
// 项目实际代码：
import "./index.css";

export default function Card() {
  return (
    <div className="card">
      <header>
        <div>标题</div>
        <div>副标题</div>
      </header>
      <main>内容区域</main>
      <footer>
        <button>确认</button>
        <button>取消</button>
      </footer>
    </div>
  );
}
```

### 使用局部组件

在 `App.tsx` 中引入和使用：

```tsx
// 项目实际代码：
import Card from "./components/Card";

function App() {
  return (
    <>
      <Card></Card>
      <Card></Card>
    </>
  );
}
```

**特点**：
- 按需引入，在需要使用的地方才导入
- 每个组件都有自己的样式文件
- 组件间相互独立，易于维护

---

## 全局组件实践 - Message 组件

### 项目目录结构

```
src/
├── components/
│   └── Message/
│       ├── index.tsx    # 组件主文件
│       └── index.css    # 组件样式
└── main.tsx
```

### 样式文件 (Message/index.css)

```css
.message {
  width: 160px;
  height: 30px;
  position: fixed;
  top: 10px;
  left: 50%;
  margin-left: -80px;
  background: #fff;
  border: 1px solid #ccc;
  text-align: center;
  line-height: 30px;
  border-radius: 5px;
}
```

### 组件实现原理

全局组件的核心思想是**命令式渲染**：通过 JavaScript 函数调用来动态创建和销毁组件实例。

#### 队列管理系统

由于用户可能连续点击触发多个消息，需要一个队列来管理：
- **防止重叠**：通过累加高度让多个消息依次排列
- **有序销毁**：按照创建顺序依次删除

### 组件主文件 (Message/index.tsx)

```tsx
// 项目实际代码：
import ReactDom from "react-dom/client";
import "./index.css";

// 消息组件本体
const Message = () => {
  return <div>提示组件</div>;
};

// 队列项接口定义
interface Item {
  msgContainer: HTMLDivElement;  // DOM 容器
  root: ReactDom.Root;          // React 根实例
}

// 全局队列管理
const queue: Item[] = [];

// 全局方法：显示消息
window.onShow = () => {
  // 1. 创建 DOM 容器
  const msgContainer = document.createElement("div");
  msgContainer.className = "message";
  msgContainer.style.top = `${queue.length * 50}px`; // 避免重叠
  document.body.appendChild(msgContainer);

  // 2. 创建 React 根并渲染组件
  const root = ReactDom.createRoot(msgContainer);
  root.render(<Message />);

  // 3. 加入队列管理
  queue.push({
    msgContainer,
    root,
  });

  // 4. 定时自动销毁（2秒后）
  setTimeout(() => {
    const item = queue.find((item) => item.msgContainer === msgContainer)!;
    item.root.unmount();                              // 卸载 React 组件
    document.body.removeChild(item.msgContainer);     // 移除 DOM 元素
    queue.splice(queue.indexOf(item), 1);             // 从队列中移除
  }, 2000);
};

// TypeScript 全局声明扩充
declare global {
  interface Window {
    onShow: () => void;
  }
}

export default Message;
```

### 核心 API 解析

#### ReactDOM.createRoot() 和 root.render()

```tsx
const root = ReactDom.createRoot(msgContainer);  // 创建 React 根
root.render(<Message />);                        // 渲染组件到根
```

这是 React 18 的新 API，用于：
- **动态渲染**：在任意 DOM 节点中渲染 React 组件
- **独立管理**：每个根实例独立管理自己的组件树
- **命令式操作**：通过 JavaScript 代码控制组件的创建和销毁

#### 生命周期管理

```tsx
// 创建阶段
1. createElement()     // 创建 DOM 容器
2. createRoot()        // 创建 React 根
3. render()           // 渲染组件
4. queue.push()       // 加入管理队列

// 销毁阶段
1. root.unmount()              // 卸载 React 组件
2. removeChild()               // 移除 DOM 元素
3. queue.splice()              // 清理队列数据
```

### 使用全局组件

#### 在 main.tsx 中导入全局组件

```tsx
// 项目实际代码 - main.tsx：
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import "./components/Message/index.tsx"; // 全局组件在应用入口导入

createRoot(document.getElementById("root")!).render(<App />);
```

#### 在组件中调用全局方法

```tsx
// 项目实际代码 - App.tsx：
import Card from "./components/Card";

function App() {
  return (
    <>
      <button onClick={() => window.onShow()}>打开消息</button>
      <Card></Card>
      <Card></Card>
    </>
  );
}
```

**特点**：
- **应用入口导入**：在 main.tsx 中导入，确保全局方法可用
- **命令式调用**：通过全局方法触发，不依赖组件树结构
- **动态创建**：每次调用都创建新的实例和独立的渲染根
- **自动管理**：具备完整的生命周期管理（创建→显示→销毁）
- **队列控制**：支持多实例并发显示，自动处理位置排列

---

## 组件开发最佳实践

### 1. 目录结构规范

```
components/
├── Button/           # 基础组件
│   ├── index.tsx
│   └── index.css
├── Card/            # 业务组件
│   ├── index.tsx
│   └── index.css
└── Message/         # 全局组件
    ├── index.tsx
    └── index.css
```

### 2. 组件分类

- **基础组件**：Button、Input、Modal 等通用 UI 组件
- **业务组件**：UserCard、ProductList 等业务相关组件
- **布局组件**：Header、Footer、Sidebar 等布局组件
- **全局组件**：Message、Toast、Loading 等全局功能组件

### 3. 导入导出规范

```tsx
// 统一使用 default export
export default function ComponentName() {
  // 组件逻辑
}

// 在 index.tsx 中集中导出
export { default } from './ComponentName';
```

### 4. 样式管理

- 每个组件都有独立的 CSS 文件
- 使用有意义的类名，避免全局污染
- 考虑使用 CSS Modules 或 styled-components

---

## React 组件重新渲染机制

理解组件重新渲染机制对于性能优化和调试至关重要。

### 什么会触发组件重新渲染？

1. **状态变化** (`useState`, `useReducer`)
   - 组件内部状态发生改变
   - 即使新值与旧值相同，也可能触发渲染（React 会进行浅比较）

2. **Props 变化**
   - 父组件传递的 props 发生改变
   - 对象或数组引用改变（即使内容相同）

3. **父组件重新渲染**
   - 父组件渲染时，所有子组件默认也会重新渲染
   - 这是 React 的默认行为，可通过 `React.memo` 优化

4. **Context 值变化**
   - 使用的 Context Provider 的 value 发生改变
   - 所有订阅该 Context 的组件都会重新渲染

5. **自定义 Hook 返回的状态变化**
   - 如 `useQuery` 返回的 `isLoading`、`data` 等状态改变
   - Hook 内部状态变化会导致使用该 Hook 的组件重新渲染

### 组件重新渲染时的执行流程

#### ✅ 会重新执行的代码

- **整个函数组件体**
  ```tsx
  function MyComponent() {
    console.log('每次渲染都会执行'); // ✅ 重新执行

    const someValue = Math.random(); // ✅ 重新计算
    const handleClick = () => {     // ✅ 重新创建函数
      console.log('点击处理');
    };

    return <div>{someValue}</div>; // ✅ 重新返回 JSX
  }
  ```

- **所有 Hook 调用**
  ```tsx
  const [count, setCount] = useState(0);    // ✅ 重新调用
  const { data } = useQuery(queryOptions);  // ✅ 重新调用
  ```

- **所有普通的 JavaScript 代码**
  - 变量声明、函数定义、计算表达式
  - `console.log` 等调试语句
  - 条件判断、循环等逻辑

#### ❌ 不会重新执行的代码

- **函数组件外部的代码**
  ```tsx
  console.log('组件外部，只执行一次'); // ❌ 不会重新执行

  const fetchData = async () => {
    // 函数定义在组件外部，不会重新创建
  };

  function MyComponent() {
    // 组件内部代码会重新执行
  }
  ```

- **某些 Hook 的回调函数**（依赖项未变化时）
  ```tsx
  function MyComponent({ userId }) {
    // ❌ deps 未变化时，effect 不重新执行
    useEffect(() => {
      console.log('只在 userId 变化时执行');
    }, [userId]);

    // ❌ deps 未变化时，不重新计算
    const expensiveValue = useMemo(() => {
      return heavyCalculation();
    }, [userId]);

    // ❌ deps 未变化时，不重新创建函数
    const memoizedCallback = useCallback(() => {
      doSomething(userId);
    }, [userId]);
  }
  ```

### 实际示例理解

```tsx
function ReactQuery() {
  console.log('=== 组件开始渲染 ==='); // ✅ 每次渲染都执行

  // ✅ useQuery 每次都调用，但内部有缓存优化
  const { data, isFetching, refetch } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos, // ❌ 这个函数不一定执行（取决于缓存）
  });

  console.log('当前状态:', isFetching); // ✅ 每次渲染都执行

  // 当调用 refetch() 时的执行流程：
  // 1. refetch() 触发新的网络请求
  // 2. useQuery 内部状态变化（isFetching: false → true）
  // 3. React 检测到状态变化，触发组件重新渲染
  // 4. 整个 ReactQuery 函数重新执行
  // 5. 上述所有 console.log 都会重新执行

  return <div>...</div>; // ✅ 每次渲染都执行
}
```

### 性能优化要点

1. **避免在渲染过程中创建新对象**
   ```tsx
   // ❌ 每次渲染都创建新对象
   const style = { color: 'red' };

   // ✅ 使用 useMemo 缓存
   const style = useMemo(() => ({ color: 'red' }), []);
   ```

2. **合理使用 useCallback 和 useMemo**
   - 只在真正需要时使用，过度使用反而影响性能
   - 重点优化传递给子组件的函数和复杂计算

3. **理解 React.memo 的作用**
   - 防止父组件渲染导致子组件不必要的重新渲染
   - 只对 props 进行浅比较

---

## 总结

组件是 React 应用的基石，通过合理的组件设计可以：

1. **提高复用性**：相同的 UI 逻辑可以在多处使用
2. **便于维护**：每个组件职责单一，修改影响范围小
3. **增强可测试性**：独立组件更容易编写单元测试
4. **改善开发体验**：清晰的组件结构提高开发效率

**关键理解**：
- React 组件就是函数，每次渲染就是重新调用这个函数
- 理解重新渲染机制有助于性能优化和问题调试
- 合理使用优化手段，避免不必要的重复计算和渲染

局部组件和全局组件各有适用场景，选择合适的模式能让应用架构更加清晰和高效。